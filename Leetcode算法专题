一. 动态规划算法概述
1.什么是动态规划算法
首先，动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。
既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。
掌握递归思维，只有列出正确的「状态转移方程」，才能正确地穷举。而且，你需要判断算法问题是否具备「最优子结构」，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题存在「重叠子问题」，使用「备忘录」或者「DP table」来优化穷举过程。
重叠子问题、最优子结构、状态转移方程就是动态规划三要素。
动态规划思维框架：明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。

2.什么样的问题可以考虑使用动态规划解决呢？

如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划。

比如一些求最值的场景，如最长递增子序列、最小编辑距离、背包问题、凑零钱问、序列问题、贪心类型、游戏迷宫等等，都是动态规划的经典应用场景。
动态规划的解题思路
动态规划的核心思想就是拆分子问题，记住过往，减少重复计算。(子问题之间完全独立，上下层问题之间完全依赖)  并且动态规划一般都是自底向上的，做动态规划的思路：

穷举分析
确定边界
找出规律，确定最优子结构
写出状态转移方程

更术语的解释：blog.csdn.net/qq_37763204…
二. 动态规划细节讲解
1）重叠子问题
LeetCode509: 斐波那契数列

解决方案：使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典）

2）最优子结构
Leetcode322: 零钱兑换
要符合「最优子结构」，子问题间必须互相独立（类似数学归化思想）

假设你有面值为 1, 2, 5 的硬币，你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10, 9, 6 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1, 2, 5 的硬币），求个最小值，就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。

自顶向下：
dp 函数：dp(n) 表示，输入一个目标金额 n，返回凑出目标金额 n 所需的最少硬币数量。

自底向上
dp 数组的迭代解法
自底向上使用 dp table 来消除重叠子问题，dp 数组的定义：当目标金额为 i 时，至少需要 dp[i] 枚硬币凑出。

3） 状态转移方程
设计动态规划的通用技巧：数学归纳思想
Leetcode300: 最长递增子序列
数学归纳思想：我们先假设这个结论在 k < n 时成立，然后根据这个假设，想办法推导证明出 k = n 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。
同理：假设 dp[0...i-1] 都已经被算出来了，可以通过这些结果算出 dp[i]
定义：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。

nums[5] = 3，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到这些子序列末尾，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。

扑克牌二分法优化
时间复杂度为 O(NlogN)


拓展到二维
Leetcode:354 俄罗斯套娃信封问题
这道题目其实是最长递增子序列的一个变种，因为每次合法的嵌套是大的套小的，相当于在二维平面中找一个最长递增的子序列，其长度就是最多能嵌套的信封个数。
解题思路：
先对宽度 w 进行升序排序，如果遇到 w 相同的情况，则按照高度 h 降序排序；之后把所有的 h 作为一个数组，在这个数组上计算 LIS 的长度就是答案。



三.真题实战
1).Leetcode 53：最大子序和
dp数组含义：以 nums[i] 为结尾的「最大子数组和」为 dp[i]

2).Leetcode 1143：最长公共子序列
base case: dp[0][0]=0


3).Leetcode 583. 两个字符串的删除操作
结合上一题“最长公共子序列”

4).Leetcode 712. 两个字符串的最小ASCII删除和
结合上一题“最长公共子序列”

四.拓展：背包问题
给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？
第一步要明确两点，「状态」和「选择」

状态是「背包的容量」和「可选择的物品」
选择是「装进背包」或者「不装进背包」

第二步要明确 dp 数组的定义

dp[i][j]：对于前i个物品，当前容量j,产生的最大价值就是dp[i][j]
base case是 dp[...][0] = dp[0][...] = 0,因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。

第三步，根据「选择」，思考状态转移的逻辑


Leetcode416: 分割等和子集


Leetcode518: 零钱兑换II

一. 动态规划算法概述
1.什么是动态规划算法
首先，动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。
既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。
掌握递归思维，只有列出正确的「状态转移方程」，才能正确地穷举。而且，你需要判断算法问题是否具备「最优子结构」，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题存在「重叠子问题」，使用「备忘录」或者「DP table」来优化穷举过程。
重叠子问题、最优子结构、状态转移方程就是动态规划三要素。
动态规划思维框架：明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。

2.什么样的问题可以考虑使用动态规划解决呢？

如果一个问题，可以把所有可能的答案穷举出来，并且穷举出来后，发现存在重叠子问题，就可以考虑使用动态规划。

比如一些求最值的场景，如最长递增子序列、最小编辑距离、背包问题、凑零钱问、序列问题、贪心类型、游戏迷宫等等，都是动态规划的经典应用场景。
动态规划的解题思路
动态规划的核心思想就是拆分子问题，记住过往，减少重复计算。(子问题之间完全独立，上下层问题之间完全依赖)  并且动态规划一般都是自底向上的，做动态规划的思路：

穷举分析
确定边界
找出规律，确定最优子结构
写出状态转移方程

更术语的解释：blog.csdn.net/qq_37763204…
二. 动态规划细节讲解
1）重叠子问题
LeetCode509: 斐波那契数列

解决方案：使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典）

2）最优子结构
Leetcode322: 零钱兑换
要符合「最优子结构」，子问题间必须互相独立（类似数学归化思想）

假设你有面值为 1, 2, 5 的硬币，你想求 amount = 11 时的最少硬币数（原问题），如果你知道凑出 amount = 10, 9, 6 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1, 2, 5 的硬币），求个最小值，就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。

自顶向下：
dp 函数：dp(n) 表示，输入一个目标金额 n，返回凑出目标金额 n 所需的最少硬币数量。

自底向上
dp 数组的迭代解法
自底向上使用 dp table 来消除重叠子问题，dp 数组的定义：当目标金额为 i 时，至少需要 dp[i] 枚硬币凑出。

3） 状态转移方程
设计动态规划的通用技巧：数学归纳思想
Leetcode300: 最长递增子序列
数学归纳思想：我们先假设这个结论在 k < n 时成立，然后根据这个假设，想办法推导证明出 k = n 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。
同理：假设 dp[0...i-1] 都已经被算出来了，可以通过这些结果算出 dp[i]
定义：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。

nums[5] = 3，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到这些子序列末尾，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。

扑克牌二分法优化
时间复杂度为 O(NlogN)


拓展到二维
Leetcode:354 俄罗斯套娃信封问题
这道题目其实是最长递增子序列的一个变种，因为每次合法的嵌套是大的套小的，相当于在二维平面中找一个最长递增的子序列，其长度就是最多能嵌套的信封个数。
解题思路：
先对宽度 w 进行升序排序，如果遇到 w 相同的情况，则按照高度 h 降序排序；之后把所有的 h 作为一个数组，在这个数组上计算 LIS 的长度就是答案。



三.真题实战
1).Leetcode 53：最大子序和
dp数组含义：以 nums[i] 为结尾的「最大子数组和」为 dp[i]

2).Leetcode 1143：最长公共子序列
base case: dp[0][0]=0


3).Leetcode 583. 两个字符串的删除操作
结合上一题“最长公共子序列”

4).Leetcode 712. 两个字符串的最小ASCII删除和
结合上一题“最长公共子序列”

四.拓展：背包问题
给你一个可装载重量为 W 的背包和 N 个物品，每个物品有重量和价值两个属性。其中第 i 个物品的重量为 wt[i]，价值为 val[i]，现在让你用这个背包装物品，最多能装的价值是多少？
第一步要明确两点，「状态」和「选择」

状态是「背包的容量」和「可选择的物品」
选择是「装进背包」或者「不装进背包」

第二步要明确 dp 数组的定义

dp[i][j]：对于前i个物品，当前容量j,产生的最大价值就是dp[i][j]
base case是 dp[...][0] = dp[0][...] = 0,因为没有物品或者背包没有空间的时候，能装的最大价值就是 0。

第三步，根据「选择」，思考状态转移的逻辑


Leetcode416: 分割等和子集


Leetcode518: 零钱兑换II


题目3: K 距离间隔重排字符串
题目：  给你一个非空的字符串 s 和一个整数 k，你要将这个字符串中的字母进行重新排列，使得重排后的字符串中相同字母的位置间隔距离至少为 k。

所有输入的字符串都由小写字母组成，如果找不到距离至少为 k 的重排结果，请返回一个空字符串 “”  
说明：你不能倾斜容器。

示例 1： 
    输入: s = "aabbcc", k = 3 
    输出: "abcabc" 
    解释: 相同的字母在新的字符串中间隔至少 3 个单位距离。 
示例 2: 
    输入: s = "aaabc", k = 3 
    输出: "" 
    解释: 没有办法找到可能的重排结果。
示例 3 
    输入: s = "aaadbbcc", k = 2 
    输出: "abacabcd" 
    解释: 相同的字母在新的字符串中间隔至少 2 个单位距离。
    
   
